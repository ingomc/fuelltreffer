---
import Layout from '../../../../layouts/Layout.astro';

const { eventId, matchId } = Astro.params;

// Get team parameter if present (for back navigation)
const teamParam = Astro.url.searchParams.get('team');
const backUrl = teamParam ? `/?team=${teamParam}` : '/';
---

<Layout title={`Match Details - ${matchId}`}>
  <main class="min-h-screen bg-gray-50 dark:bg-gray-900 transition-colors duration-200">
    <!-- Header with back button -->
    <div class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 sticky top-0 z-10">
      <div class="container mx-auto px-4 py-4">
        <div class="flex items-center gap-4">
          <a 
            href={backUrl}
            class="inline-flex items-center gap-2 px-4 py-2 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-lg transition-colors text-gray-900 dark:text-gray-100"
          >
            <span>‚Üê</span>
            <span>Zur√ºck</span>
          </a>
          <h1 class="text-2xl font-bold text-gray-900 dark:text-gray-100">
            üéØ Match Report
          </h1>
        </div>
      </div>
    </div>

    <!-- Match Report Component -->
    <div class="container mx-auto px-4 py-8">
      <div id="match-report-container" class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
        <!-- Loading state -->
        <div id="loading" class="flex items-center justify-center py-12">
          <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
        </div>
        
        <!-- Error state -->
        <div id="error" class="hidden text-center py-12">
          <span class="text-4xl">‚ùå</span>
          <p class="text-red-600 dark:text-red-400 mt-2">Fehler beim Laden des Match Reports</p>
          <p id="error-message" class="text-gray-500 text-sm mt-1"></p>
        </div>
        
        <!-- Content -->
        <div id="content" class="hidden space-y-6"></div>
      </div>
    </div>
  </main>
</Layout>

<script define:vars={{ eventId, matchId, teamParam }}>
  // Fetch match report data
  async function fetchMatchReport() {
    const loadingEl = document.getElementById('loading');
    const errorEl = document.getElementById('error');
    const errorMessageEl = document.getElementById('error-message');
    const contentEl = document.getElementById('content');

    try {
      // Fetch report first
      const reportResponse = await fetch(`/api/match/${eventId}/${matchId}/report`);
      
      if (!reportResponse.ok) {
        throw new Error(`HTTP error! status: ${reportResponse.status}`);
      }
      
      const reportData = await reportResponse.json();
      console.log('Report loaded, games:', reportData.length);
      
      // Get round info from first game to fetch ALL matches of this round
      const firstGame = reportData[0];
      const phaseId = firstGame.round?.phase?.id;
      const roundIndex = firstGame.round?.roundIndex;
      
      console.log('üéØ Round info - Phase:', phaseId, 'Round:', roundIndex);
      
      // Fetch ALL matches of this round (all teams playing on this match day)
      let allRoundMatches = [];
      if (phaseId && roundIndex !== undefined) {
        try {
          console.log('üì• Loading all matches for this round...');
          const roundResponse = await fetch(`/api/round/${eventId}/${phaseId}/${roundIndex}`);
          if (roundResponse.ok) {
            const roundData = await roundResponse.json();
            allRoundMatches = roundData.matches || [];
            console.log('‚úÖ Loaded', allRoundMatches.length, 'matches from round');
          }
        } catch (e) {
          console.error('Failed to load round matches:', e);
        }
      }
      
      // Fetch statistics for EACH game in EACH match of the round
      const allStats = [];
      
      for (const match of allRoundMatches) {
        // Get the match report for each match
        try {
          const matchReportResponse = await fetch(`/api/match/${eventId}/${match.id}/report`);
          if (matchReportResponse.ok) {
            const matchGames = await matchReportResponse.json();
            console.log(`üìä Match ${match.id}: ${matchGames.length} games`);
            
            // For each game in the match, fetch statistics
            for (const game of matchGames) {
              if (game.hasPerformances) {
                try {
                  const statsResponse = await fetch(`/api/match/${eventId}/${game.id}/statistics`);
                  if (statsResponse.ok) {
                    const gameStats = await statsResponse.json();
                    if (gameStats.length > 0) {
                      console.log(`  ‚úÖ Game ${game.gameNr}: ${gameStats.length} stats`);
                      allStats.push(...gameStats);
                    }
                  }
                } catch (e) {
                  console.error(`Failed to load stats for game ${game.id}:`, e);
                }
              }
            }
          }
        } catch (e) {
          console.error(`Failed to load match ${match.id}:`, e);
        }
      }
      
      console.log('üìä Total statistics loaded:', allStats.length, 'entries from all matches');
      
      // Load team roster if teamParam is provided
      let teamRoster = null;
      if (teamParam) {
        try {
          console.log(`üîç Loading roster for team ${teamParam}`);
          const rosterResponse = await fetch(`/api/participant/${teamParam}`);
          if (rosterResponse.ok) {
            teamRoster = await rosterResponse.json();
            console.log(`‚úÖ Team roster loaded: ${teamRoster?.members?.length || 0} members`);
          }
        } catch (e) {
          console.error('Failed to load team roster:', e);
        }
      }
      
      // Hide loading
      loadingEl.classList.add('hidden');
      
      // Show content
      contentEl.classList.remove('hidden');
      
      // Render the match report
      renderMatchReport(reportData, allStats.length > 0 ? allStats : null, teamRoster, contentEl);
      
    } catch (error) {
      console.error('Error fetching match report:', error);
      
      // Hide loading
      loadingEl.classList.add('hidden');
      
      // Show error
      errorEl.classList.remove('hidden');
      errorMessageEl.textContent = error.message;
    }
  }

  function formatDate(dateString) {
    if (!dateString) return 'N/A';
    const date = new Date(dateString);
    return date.toLocaleString('de-DE', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  function formatDuration(seconds) {
    if (!seconds) return 'N/A';
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')} min`;
  }

  function calculateAverage(scoreTotal, dartsTotal) {
    if (!dartsTotal || dartsTotal === 0) return 0;
    return (scoreTotal / dartsTotal * 3).toFixed(2);
  }

  function renderMatchReport(data, statsData, teamRoster, container) {
    if (!data || data.length === 0) {
      container.innerHTML = '<p class="text-center text-gray-500">Keine Daten verf√ºgbar</p>';
      return;
    }

    // Get first match for general info
    const firstMatch = data[0];
    
    // Try to find team names by looking at all participants
    // Group by home/away and collect unique team names
    const homeTeams = new Set();
    const awayTeams = new Set();
    
    data.forEach(match => {
      if (match.participantHome?.teamSeason?.team?.name) {
        homeTeams.add(match.participantHome.teamSeason.team.name);
      }
      if (match.participantGuest?.teamSeason?.team?.name) {
        awayTeams.add(match.participantGuest.teamSeason.team.name);
      }
    });
    
    const homeTeamName = homeTeams.size === 1 ? [...homeTeams][0] : 
                         firstMatch.participantHome?.teamSeason?.team?.name || 
                         'Heimteam';
    const awayTeamName = awayTeams.size === 1 ? [...awayTeams][0] : 
                         firstMatch.participantGuest?.teamSeason?.team?.name || 
                         'Gastteam';
    
    let html = '';

    // Compact Header with Score
    const totalLegsHome = data.reduce((sum, m) => sum + (m.legsHome || 0), 0);
    const totalLegsAway = data.reduce((sum, m) => sum + (m.legsAway || 0), 0);
    
    html += `
      <div class="bg-gradient-to-r from-blue-500 to-blue-600 dark:from-blue-600 dark:to-blue-700 rounded-lg p-4 text-white">
        <div class="flex items-center justify-between mb-3">
          <div class="text-sm opacity-90">${firstMatch.event?.name || 'Liga'} ‚Ä¢ ${firstMatch.round?.name || 'Runde'}</div>
          <div class="text-sm opacity-90">Match #${firstMatch.gameNr || ''}</div>
        </div>
        
        <div class="grid grid-cols-3 gap-4 items-center">
          <!-- Home Team -->
          <div class="text-center">
            <div class="text-xs opacity-75 mb-1">üè† Heim</div>
            <div class="text-lg font-bold mb-1">${homeTeamName}</div>
            <div class="text-3xl font-bold">${totalLegsHome}</div>
          </div>
          
          <!-- VS & Info -->
          <div class="text-center">
            <div class="text-2xl font-bold opacity-50 mb-1">VS</div>
            <div class="text-xs opacity-75">
              ${formatDate(firstMatch.beginDate || firstMatch.datePlanned).split(',')[0]}
            </div>
            ${firstMatch.duration ? `
              <div class="text-xs opacity-75">‚è±Ô∏è ${formatDuration(firstMatch.duration)}</div>
            ` : ''}
          </div>
          
          <!-- Away Team -->
          <div class="text-center">
            <div class="text-xs opacity-75 mb-1">üöó Gast</div>
            <div class="text-lg font-bold mb-1">${awayTeamName}</div>
            <div class="text-3xl font-bold">${totalLegsAway}</div>
          </div>
        </div>
      </div>
    `;

    // Compact Match Details
    html += `
      <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-3">
        <div class="flex items-center justify-between text-sm">
          <div class="flex gap-4">
            <div><span class="text-gray-600 dark:text-gray-400">Modus:</span> <span class="font-bold text-gray-900 dark:text-gray-100">${firstMatch.matchmode?.matchmodePoints || 'N/A'}</span></div>
            <div><span class="text-gray-600 dark:text-gray-400">In/Out:</span> <span class="font-medium text-gray-900 dark:text-gray-100">${firstMatch.matchmode?.matchmodeInCd} / ${firstMatch.matchmode?.matchmodeOutCd}</span></div>
            <div><span class="text-gray-600 dark:text-gray-400">Legs:</span> <span class="font-medium text-gray-900 dark:text-gray-100">Best of ${firstMatch.matchmode?.legsBestOf || 'N/A'}</span></div>
          </div>
          <div class="px-2 py-1 rounded text-xs font-medium ${
            firstMatch.statusCd === 'FINISH' ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200' :
            firstMatch.statusCd === 'ACTIVE' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200' :
            'bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200'
          }">
            ${firstMatch.statusCd === 'FINISH' ? '‚úÖ Beendet' :
              firstMatch.statusCd === 'ACTIVE' ? 'üü¢ Aktiv' :
              firstMatch.statusCd || 'Offen'}
          </div>
        </div>
      </div>
    `;

    // Group games by block
    const blockGroups = {};
    data.forEach(game => {
      const blockKey = game.matchReportBlock ? 
        `${game.matchReportBlock.blockIndex}_${game.matchReportBlock.matchTypeCd}` : 
        'other';
      
      if (!blockGroups[blockKey]) {
        blockGroups[blockKey] = {
          block: game.matchReportBlock,
          games: []
        };
      }
      blockGroups[blockKey].games.push(game);
    });

    // Render blocks
    Object.entries(blockGroups).forEach(([key, group]) => {
      const block = group.block;
      const games = group.games;
      
      if (!block) return;
      
      const matchTypeLabel = block.matchTypeCd === 'EZ' ? 'Einzel' : 
                            block.matchTypeCd === 'DP' ? 'Doppel' : 
                            block.matchTypeCd;
      
      html += `
        <div class="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 overflow-hidden">
          <!-- Block Header -->
          <div class="bg-gradient-to-r from-orange-500 to-orange-600 dark:from-orange-600 dark:to-orange-700 p-3 flex items-center justify-between text-white">
            <div class="font-bold">
              ${block.blockIndex}. Block: ${block.numberOfMatches} ${matchTypeLabel}
            </div>
            <div class="text-sm opacity-90">
              Best of ${block.matchmode?.legsBestOf || 3} Legs, ${block.matchmode?.matchmodePoints || 501}
            </div>
          </div>
          
          <!-- Games in Block -->
          <div class="bg-gray-900 dark:bg-gray-950">
      `;
      
      games.forEach((game, index) => {
        const winner = game.legsHome > game.legsAway ? 'home' : game.legsAway > game.legsHome ? 'away' : 'draw';
        const boardIcon = game.matchReportBlock?.blockIndex ? 
          `<div class="w-8 h-8 bg-blue-500 dark:bg-blue-600 rounded-full flex items-center justify-center text-white font-bold text-sm">${game.gameNrRound || index + 1}</div>` :
          '';
        
        // Get player names
        const homePlayer = game.participantHome?.displayName || 'N/A';
        const awayPlayer = game.participantGuest?.displayName || 'N/A';
        
        // Determine text colors based on winner
        const homeColor = winner === 'home' ? 'text-green-400' : 'text-white';
        const awayColor = winner === 'away' ? 'text-green-400' : 'text-white';
        
        html += `
          <div class="p-3 border-b border-gray-800 dark:border-gray-900 hover:bg-gray-800 dark:hover:bg-gray-900 transition-colors">
            <div class="flex items-center gap-3">
              <!-- Game Number in Board Circle -->
              ${boardIcon}
              
              <!-- Game Number -->
              <div class="text-gray-400 text-sm font-medium w-6">${game.gameNr || index + 1}</div>
              
              <!-- Home Player -->
              <div class="flex-1 text-right ${homeColor} font-medium">
                ${homePlayer}
              </div>
              
              <!-- Score -->
              <div class="text-2xl font-bold text-white px-4">
                ${game.legsHome || 0}-${game.legsAway || 0}
              </div>
              
              <!-- Away Player -->
              <div class="flex-1 text-left ${awayColor} font-medium">
                ${awayPlayer}
              </div>
              
              <!-- Board Info -->
              ${game.board ? `<div class="text-gray-500 text-xs">Board ${game.board}</div>` : ''}
            </div>
          </div>
        `;
      });
      
      html += `
          </div>
        </div>
      `;
    });

    // Player Statistics - Alle Spieler mit ihren Spielen am Spieltag
    console.log('Checking stats data...', statsData ? 'Available' : 'Not available');
    
    if (statsData && statsData.length > 0) {
      console.log('üìä Rendering statistics - Stats Data:', statsData.length, 'entries');
      
      // Get all MATCH statistics (one per player per EINZELSPIEL)
      const matchStats = statsData.filter(s => s.type === 'MATCH');
      
      console.log('Match Stats (Einzelspiele):', matchStats.length);
      
      // Bestimme welches Team die ausgew√§hlte Mannschaft ist (aus teamParam)
      const selectedTeamId = teamParam ? parseInt(teamParam) : null;
      
      // Finde heraus welches Team Heim/Gast ist
      const firstGame = data[0];
      const homeTeamId = firstGame.participantHome?.teamSeason?.team?.id;
      const awayTeamId = firstGame.participantGuest?.teamSeason?.team?.id;
      
      console.log('üè† Home Team ID:', homeTeamId, 'üöó Away Team ID:', awayTeamId, 'üéØ Selected Team:', selectedTeamId);
      
      // Alle Spieler der ausgew√§hlten Mannschaft (aus Team Roster)
      let allTeamPlayers = [];
      let isHomeTeam = false;
      
      if (teamRoster && teamRoster.members) {
        allTeamPlayers = teamRoster.members.map(m => ({
          id: m.id,
          name: m.displayName || m.name || 'N/A'
        }));
        console.log('üë• Team roster loaded:', allTeamPlayers.length, 'players');
        
        // Pr√ºfe ob selected team = home oder away
        isHomeTeam = selectedTeamId === homeTeamId;
        console.log('Selected team is:', isHomeTeam ? 'HOME' : 'AWAY');
      }
      
      // Gruppiere Statistiken nach Spieler-ID oder Name
      const playerStatsMap = new Map();
      
      matchStats.forEach(stat => {
        // Verwende participant ID als Key, falls vorhanden
        const key = stat.participant?.id || stat.displayName;
        if (!playerStatsMap.has(key)) {
          playerStatsMap.set(key, []);
        }
        playerStatsMap.get(key).push(stat);
      });
      
      console.log('Players with stats:', playerStatsMap.size);
      
      // Baue Statistiken f√ºr ALLE Team-Spieler auf (auch ohne Spiele)
      const teamPlayerStats = new Map();
      
      if (allTeamPlayers.length > 0) {
        // F√ºr jeden Spieler im Roster
        allTeamPlayers.forEach(player => {
          // Suche seine Statistiken
          const stats = playerStatsMap.get(player.id) || 
                       playerStatsMap.get(player.name) || 
                       [];
          
          teamPlayerStats.set(player.name, stats);
        });
        console.log('‚úÖ Team stats built for', teamPlayerStats.size, 'players');
      } else {
        // Fallback: Zeige nur Spieler mit Stats (alte Logik)
        console.log('‚ö†Ô∏è No roster available, showing only players with stats');
        
        // Sammle alle Spieler die im Match gespielt haben
        const allPlayedParticipants = new Set();
        data.forEach(game => {
          if (isHomeTeam) {
            allPlayedParticipants.add(game.participantHome.displayName);
          } else {
            allPlayedParticipants.add(game.participantGuest.displayName);
          }
        });
        
        // Nur Spieler mit Stats von der ausgew√§hlten Seite
        playerStatsMap.forEach((stats, key) => {
          const playerName = stats[0]?.displayName || key;
          if (allPlayedParticipants.has(playerName)) {
            teamPlayerStats.set(playerName, stats);
          }
        });
      }
      
      html += '<div class="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 overflow-hidden mt-6">';
      html += '<div class="bg-gradient-to-r from-purple-500 to-purple-600 dark:from-purple-600 dark:to-purple-700 p-3 text-white font-bold">';
      html += 'üìä Spieler Statistiken';
      html += '</div>';
      
      // Show stats for selected team only
      if (teamPlayerStats.size > 0) {
        const teamDisplayName = isHomeTeam ? homeTeamName : awayTeamName;
        const teamIcon = isHomeTeam ? 'üè†' : 'üöó';
        const colorScheme = isHomeTeam ? 'blue' : 'green';
        
        html += '<div class="p-3 bg-' + colorScheme + '-50 dark:bg-' + colorScheme + '-950 border-b border-gray-200 dark:border-gray-700">';
        html += '<div class="font-bold text-' + colorScheme + '-900 dark:text-' + colorScheme + '-100 mb-3">' + teamIcon + ' ' + teamDisplayName + '</div>';
        html += '<div class="overflow-x-auto">';
        html += '<table class="w-full text-sm border-collapse">';
        html += '<thead class="text-xs text-' + colorScheme + '-700 dark:text-' + colorScheme + '-300 bg-' + colorScheme + '-100 dark:bg-' + colorScheme + '-900">';
        html += '<tr>';
        html += '<th class="text-left p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800">Spieler</th>';
        html += '<th class="text-center p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800">Spiele</th>';
        html += '<th class="text-center p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800">Legs Won</th>';
        html += '<th class="text-center p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800 bg-' + colorScheme + '-200 dark:bg-' + colorScheme + '-800">√ò Gesamt</th>';
        
        // Find max number of games any player played
        let maxGames = 0;
        teamPlayerStats.forEach(stats => {
          if (stats.length > maxGames) maxGames = stats.length;
        });
        
        for (let i = 0; i < maxGames; i++) {
          html += '<th class="text-center p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800">Spiel ' + (i + 1) + '</th>';
        }
        
        html += '</tr>';
        html += '</thead>';
        html += '<tbody class="text-' + colorScheme + '-900 dark:text-' + colorScheme + '-100">';
      
        teamPlayerStats.forEach((playerGames, playerName) => {
          // Calculate overall stats
          const totalDarts = playerGames.reduce((sum, g) => sum + g.dartsTotal, 0);
          const totalScore = playerGames.reduce((sum, g) => sum + g.scoreTotal, 0);
          const totalLegsWon = playerGames.reduce((sum, g) => sum + g.legCount, 0);
          const overallAvg = playerGames.length > 0 ? calculateAverage(totalScore, totalDarts) : '-';
          
          html += '<tr class="border-b border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800 hover:bg-' + colorScheme + '-100 dark:hover:bg-' + colorScheme + '-900">';
          html += '<td class="p-2 font-medium border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800">' + playerName + '</td>';
          html += '<td class="text-center p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800">' + (playerGames.length || '-') + '</td>';
          html += '<td class="text-center p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800">' + (totalLegsWon || '-') + '</td>';
          html += '<td class="text-center p-2 font-bold text-lg border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800 bg-' + colorScheme + '-100 dark:bg-' + colorScheme + '-900">' + overallAvg + '</td>';
          
          // Add individual game averages
          for (let i = 0; i < maxGames; i++) {
            if (i < playerGames.length) {
              const game = playerGames[i];
              const gameAvg = calculateAverage(game.scoreTotal, game.dartsTotal);
              const wonClass = game.won ? 'bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 font-bold' : '';
              html += '<td class="text-center p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800 ' + wonClass + '">' + gameAvg + '</td>';
            } else {
              html += '<td class="text-center p-2 border border-' + colorScheme + '-200 dark:border-' + colorScheme + '-800 text-gray-400">-</td>';
            }
          }
          
          html += '</tr>';
        });
        
        html += '</tbody>';
        html += '</table>';
        html += '</div>';
        html += '</div>';
      }
      
      html += '</div>';
    } else {
      console.log('No stats data available:', statsData ? 'Empty array' : 'Null/undefined');
      
      // Show message that no statistics are available
      html += '<div class="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 overflow-hidden mt-6">';
      html += '<div class="bg-gradient-to-r from-purple-500 to-purple-600 dark:from-purple-600 dark:to-purple-700 p-3 text-white font-bold">';
      html += 'üìä Spieler Statistiken';
      html += '</div>';
      html += '<div class="p-6 text-center text-gray-500 dark:text-gray-400">';
      html += '<div class="text-4xl mb-3">üìä</div>';
      html += '<div class="text-lg font-medium mb-2">Keine Statistik-Daten verf√ºgbar</div>';
      html += '<div class="text-sm">F√ºr dieses Match wurden keine detaillierten Statistiken aufgezeichnet.</div>';
      html += '<div class="text-xs mt-2 text-gray-400">Nur Matches mit Dartsscorer haben Statistik-Daten.</div>';
      html += '</div>';
      html += '</div>';
    }

    // Compact Additional Info
    const infoItems = [];
    
    if (firstMatch.matchReportBlock) {
      infoItems.push(`Block ${firstMatch.matchReportBlock.blockIndex}: ${firstMatch.matchReportBlock.matchTypeCd} (${firstMatch.matchReportBlock.numberOfMatches} Spiele)`);
    }
    
    if (firstMatch.phase) {
      if (firstMatch.phase.numberOfGroups) infoItems.push(`${firstMatch.phase.numberOfGroups} Gruppen`);
      if (firstMatch.phase.lineupCd) infoItems.push(`Lineup: ${firstMatch.phase.lineupCd}`);
    }
    
    if (infoItems.length > 0) {
      html += `
        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-3">
          <div class="flex flex-wrap gap-2 text-xs text-gray-600 dark:text-gray-400">
            ${infoItems.map(item => `<span class="px-2 py-1 bg-gray-200 dark:bg-gray-600 rounded">${item}</span>`).join('')}
          </div>
        </div>
      `;
    }

    // Debug section
    html += `
      <details class="bg-gray-100 dark:bg-gray-700 rounded-lg p-4">
        <summary class="font-bold text-gray-900 dark:text-gray-100 cursor-pointer">üêõ Debug: Raw API Data</summary>
        <pre class="mt-2 text-xs overflow-auto bg-gray-200 dark:bg-gray-600 p-4 rounded text-gray-800 dark:text-gray-200 max-h-96">${JSON.stringify(data, null, 2)}</pre>
      </details>
    `;

    container.innerHTML = html;
  }

  // Fetch data on page load
  fetchMatchReport();
</script>

<style>
  /* Dark mode transitions */
  * {
    transition: background-color 0.2s, border-color 0.2s, color 0.2s;
  }
</style>
